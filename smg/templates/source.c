/**
 * @file
 * AUTOGENERATED by smg
 **/

#include <assert.h>
#include <stdbool.h>
#include <string.h>
#include "{{smg.prefix}}.h"

{% if smg.include_logging %}
#include <stdio.h>
{% endif %}


/**
 * Initialize the state machine
 * @param m State machine
 **/
void {{smg.prefix}}_init({{smg.state_machine_type}}* m) {
    assert(m != NULL);
    memset(m, 0, sizeof({{smg.state_machine_type}}));
    m->state = {{smg.default_state.enum}};
    m->prev_state = {{smg.default_state.enum}};

{% if smg.init_code %}
    {{smg.init_code}}
{% endif %}
{% if smg.include_logging and smg.include_string_funcs %}
    printf("{{smg.prefix}}::info -- {{smg.prefix}} state machine initialized\n");
    printf("{{smg.prefix}}::info -- initial state: %s\n",
           {{smg.prefix}}_get_state_name(m->state));
{% endif %}
}


/**
 * Run the state machine one step
 * @param m State machine
 **/
void {{smg.prefix}}_step({{smg.state_machine_type}}* m) {
    assert(m != NULL);

    m->prev_state = m->state;
    // Find the next state to transfer to
    switch (m->state) {
    {% for state in smg.states %}
        case {{state.enum}}:
        {% for trans in state.transitions %}
            if ({{trans.guards}}) {
            {% for event in trans.handled_events %}
                {{smg.env_name}}.{{event}} = false;
            {% endfor %}
                m->state = {{trans.to_state.enum}};
                break;
            }
        {% endfor %}
        {% if state.default_transition %}
            m->state = {{state.default_transition.to_state.enum}};
            break;
        {% else %}
            m->state = {{smg.error_state.enum}};
            break;
        {% endif %}
    {% endfor %}
        default:
            assert(false); // This state should never be reached
    }

    // Only execute the state on transitions
    if (m->state != m->prev_state || m->iterations == 0) {
        m->duration = 0;
        // Execute the new state
        switch (m->state) {
        {% for state in smg.states %}
            case {{state.enum}}:
            {% if state.state_code %}
                {{state.state_code}}
            {% endif %}
                break;
        {% endfor %}
            default:
                assert(false); // This state should never be reached
        }

    {% if smg.include_logging and smg.include_string_funcs %}
        printf("{{smg.prefix}}::info -- transition: %s -> %s\n",
               {{smg.prefix}}_get_state_name(m->prev_state),
               {{smg.prefix}}_get_state_name(m->state));
    {% endif %}

    } else {
        m->duration += 1;
    }

    m->iterations += 1;
}


{% if smg.include_string_funcs %}
/* TODO: Change this to a preprocessor directive */
/**
 * Get a string representation of the state type
 * @param state state to get name for
 * @retval const char*
 * @returns string representation of state
 **/
const char* {{smg.prefix}}_get_state_name(const {{smg.state_type}} state) {
    switch (state) {
    {% for state in smg.states %}
        case {{state.enum}}:
            return "{{state.name}}";
    {% endfor %}
    }
    assert(false);
}
{% endif %}
