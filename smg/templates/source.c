/**
 * @file
 * AUTOGENERATED by smg
 **/

#include <assert.h>
#include <stdbool.h>
#include <string.h>
#include "header.h"

{% if smg.include_logging %}
#include <stdio.h>
{% endif %}


/**
 * State functions execute when a state is first entered
 **/
typedef void (*{{smg.state_fn_type}})({{smg.state_machine_type}}*);


/**
 * Transfer functions determine the next state that should occur
 **/
typedef {{smg.state_type}} (*{{smg.trans_fn_type}})(const {{smg.state_machine_type}}*);


{% for state in smg.states %}
static void {{state.state_fn}}({{smg.state_machine_type}}* machine);
{% endfor %}


{% for state in smg.states %}
static {{smg.state_type}} {{state.trans_fn}}(const {{smg.state_machine_type}}* machine);
{% endfor %}


static const {{smg.state_fn_type}} {{smg.statefns_array}}[] = {
{% for state in smg.states %}
    {{state.state_fn}},
{% endfor %}
};


static const {{smg.trans_fn_type}} {{smg.transfns_array}}[] = {
{% for state in smg.states %}
    {{state.trans_fn}},
{% endfor %}
};


void {{smg.prefix}}_init({{smg.state_machine_type}}* m) {
    assert(m != NULL);
    memset(m, 0, sizeof({{smg.state_machine_type}}));
    m->state = {{smg.default_state.enum}};
    m->prev_state = {{smg.default_state.enum}};

{% if smg.init_code %}
    {{smg.init_code}}
{% endif %}
}


void {{smg.prefix}}_next({{smg.state_machine_type}}* m) {
    assert(m != NULL);

    m->prev_state = machine->state;
    // Find the next state to transfer to
    m->state = {{smg.transfns_array}}[m->state](m);

    // Only execute the state on transitions
    if (m->state != m->prev_state || m->iterations == 0) {
        m->duration = 0;
        // Execute the new state
        {{smg.statefns_array}}[m->state](m);
    {% if smg.include_logging and smg.include_string_funcs %}
        printf("{{smg.prefix}}::info -- executing state function %s\n",
                {{smg.prefix}}_get_state_name(m->state));
    {% endif %}

    } else {
        m->duration += 1;
    }

    m->iterations += 1;

{% if smg.include_logging and smg.include_string_funcs %}
    printf("{{smg.prefix}}::info -- transition: %s -> %s\n",
        {{smg.prefix}}_get_state_name(m->prev_state),
        {{smg.prefix}}_get_state_name(m->state));
{% endif %}
}



{% if smg.include_string_funcs %}
/**
 * Get a string representation of the state type
 * @param state state to get name for
 * @retval const char*
 * @returns string representation of state
 **/
const char* {{smg.prefix}}_get_state_name(const {{smg.state_type}} state) {
    switch (state) {
    {% for state in smg.states %}
        case {{state.enum}}:
            return "{{state.name}}";
    {% endfor %}
    }
    assert(false);
}
{% endif %}


{% for state in smg.states %}
/**
 * {{state.name}} state function
 **/
static void {{state.state_fn}}({{smg.state_machine_type}}* m) {
    assert(m != NULL);
{% if state.state_code %}
    {{state.state_code}}
{% endif %}
}
/**
 * {{state.name}} transfer function
 **/
static {{smg.state_type}} {{state.trans_fn}}(const {{smg.state_machine_type}}* m) {
    assert(m != NULL);
{% for trans in state.transitions %}
    if ({{trans.guards}}) {
        return {{trans.to_state.enum}};
    }
{% endfor %}
{% if state.default_transition %}
    return {{state.default_transition.to_state.enum}};
{% else %}
    return {{smg.error_state.enum}};
{% endif %}
}


{% endfor %}
